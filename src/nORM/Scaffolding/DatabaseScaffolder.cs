#nullable enable
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using nORM.Core;
using nORM.Configuration;
using nORM.Providers;
using Microsoft.Extensions.ObjectPool;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace nORM.Scaffolding
{
    /// <summary>
    /// Provides reverse-engineering utilities that can scaffold entity classes and a DbContext
    /// from an existing database schema.
    /// </summary>
    public static class DatabaseScaffolder
    {
        private static readonly ObjectPool<StringBuilder> _stringBuilderPool =
            new DefaultObjectPool<StringBuilder>(new StringBuilderPooledObjectPolicy());

        /// <summary>
        /// Generates entity classes and a DbContext based on the current database schema.
        /// </summary>
        /// <param name="connection">Open database connection.</param>
        /// <param name="provider">Database provider implementation.</param>
        /// <param name="outputDirectory">Directory to write generated files into.</param>
        /// <param name="namespaceName">Namespace for the generated classes.</param>
        /// <param name="contextName">Name of the generated DbContext.</param>
        public static async Task ScaffoldAsync(DbConnection connection, DatabaseProvider provider, string outputDirectory, string namespaceName, string contextName = "AppDbContext")
        {
            if (connection is null) throw new ArgumentNullException(nameof(connection));
            if (provider is null) throw new ArgumentNullException(nameof(provider));
            if (outputDirectory is null) throw new ArgumentNullException(nameof(outputDirectory));
            if (namespaceName is null) throw new ArgumentNullException(nameof(namespaceName));

            if (connection.State != ConnectionState.Open)
                await connection.OpenAsync().ConfigureAwait(false);

            try
            {
                Directory.CreateDirectory(outputDirectory);
                var tables = await connection.GetSchemaAsync("Tables").ConfigureAwait(false);
                var entityNames = new List<string>();

                foreach (DataRow table in tables.Rows)
                {
                    var tableType = table.Table.Columns.Contains("TABLE_TYPE") ? table["TABLE_TYPE"]?.ToString() : null;
                    if (tableType != null && !string.Equals(tableType, "TABLE", StringComparison.OrdinalIgnoreCase))
                        continue;

                    var tableName = table["TABLE_NAME"]!.ToString()!;
                    var schemaName = table.Table.Columns.Contains("TABLE_SCHEMA")
                        ? table["TABLE_SCHEMA"]?.ToString()
                        : null;

                    var entityName = ToPascalCase(tableName);
                    entityNames.Add(entityName);

                    var entityCode = await ScaffoldEntityAsync(connection, provider, schemaName, tableName, entityName, namespaceName).ConfigureAwait(false);
                    await File.WriteAllTextAsync(Path.Combine(outputDirectory, entityName + ".cs"), entityCode).ConfigureAwait(false);
                }

                var ctxCode = ScaffoldContext(namespaceName, contextName, entityNames);
                await File.WriteAllTextAsync(Path.Combine(outputDirectory, contextName + ".cs"), ctxCode).ConfigureAwait(false);
            }
            finally
            {
                await connection.CloseAsync().ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Generates C# source code for a single entity type based on the provided database schema information.
        /// </summary>
        /// <param name="connection">Active database connection.</param>
        /// <param name="provider">Database provider in use.</param>
        /// <param name="schemaName">Optional schema name.</param>
        /// <param name="tableName">Table name in the database.</param>
        /// <param name="entityName">Name of the entity class to produce.</param>
        /// <param name="namespaceName">Namespace for the generated entity.</param>
        /// <returns>A string containing the generated C# code.</returns>
        private static async Task<string> ScaffoldEntityAsync(DbConnection connection, DatabaseProvider provider, string? schemaName, string tableName, string entityName, string namespaceName)
        {
            var sb = _stringBuilderPool.Get();
            try
            {
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System;");
                sb.AppendLine("using System.ComponentModel.DataAnnotations;");
                sb.AppendLine("using System.ComponentModel.DataAnnotations.Schema;");
                sb.AppendLine();
                sb.AppendLine($"namespace {namespaceName};");
                sb.AppendLine();
                // Class-level [Table] with schema (if available)
                var tableAttr = schemaName is not null
                    ? $"[Table(\"{tableName}\", Schema = \"{schemaName}\")]"
                    : $"[Table(\"{tableName}\")]";
                sb.AppendLine(tableAttr);
                sb.AppendLine($"public class {EscapeCSharpIdentifier(entityName)}");
                sb.AppendLine("{");

                // Read schema using a zero-row query (fast) with key info
                await using var cmd = connection.CreateCommand();
                cmd.CommandText = $"SELECT * FROM {EscapeQualified(provider, schemaName, tableName)} WHERE 1=0";
                await using var reader = await cmd.ExecuteReaderAsync(CommandBehavior.SchemaOnly | CommandBehavior.KeyInfo).ConfigureAwait(false);
                var schema = reader.GetSchemaTable()!;
                foreach (DataRow row in schema.Rows)
                {
                    var colName = row["ColumnName"]!.ToString()!;
                    var propName = EscapeCSharpIdentifier(ToPascalCase(colName));
                    var clrType = (Type)row["DataType"]!;
                    var allowNull = row["AllowDBNull"] is bool b && b;

                    // Decide C# type name with correct nullability for value OR reference types
                    var typeName = GetTypeName(clrType, allowNull);

                    var isKey = row.Table.Columns.Contains("IsKey") && row["IsKey"] is bool key && key;
                    var isAuto = row.Table.Columns.Contains("IsAutoIncrement") && row["IsAutoIncrement"] is bool ai && ai;

                    // String length if available
                    int? maxLength = null;
                    if (clrType == typeof(string) && row.Table.Columns.Contains("ColumnSize") && row["ColumnSize"] != DBNull.Value)
                    {
                        if (int.TryParse(row["ColumnSize"]!.ToString(), out var size) && size > 0)
                            maxLength = size;
                    }

                    sb.AppendLine("    /// <summary>");
                    sb.AppendLine($"    /// Maps to column {colName}");
                    sb.AppendLine("    /// </summary>");
                    if (isKey)
                        sb.AppendLine("    [Key]");
                    if (isAuto)
                        sb.AppendLine("    [DatabaseGenerated(DatabaseGeneratedOption.Identity)]");
                    if (maxLength.HasValue)
                        sb.AppendLine($"    [MaxLength({maxLength.Value})]");
                    sb.AppendLine($"    [Column(\"{colName}\")]");
                    sb.AppendLine($"    public {typeName} {propName} {{ get; set; }}");
                    sb.AppendLine();
                }

                sb.AppendLine("}");
                return sb.ToString();
            }
            finally
            {
                sb.Clear();
                _stringBuilderPool.Return(sb);
            }
        }

        private static string ScaffoldContext(string namespaceName, string contextName, IEnumerable<string> entities)
        {
            var sb = _stringBuilderPool.Get();
            try
            {
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#nullable enable");
                sb.AppendLine("using System.Data.Common;");
                sb.AppendLine("using nORM.Core;");
                sb.AppendLine("using nORM.Configuration;");
                sb.AppendLine("using nORM.Providers;");
                sb.AppendLine();
                sb.AppendLine($"namespace {namespaceName};");
                sb.AppendLine();
                sb.AppendLine($"public class {EscapeCSharpIdentifier(contextName)} : DbContext");
                sb.AppendLine("{");
                sb.AppendLine($"    public {EscapeCSharpIdentifier(contextName)}(DbConnection cn, DatabaseProvider provider, DbContextOptions? options = null) : base(cn, provider, options) {{ }}");
                sb.AppendLine();
                foreach (var entity in entities.OrderBy(e => e))
                {
                    var safeEntity = EscapeCSharpIdentifier(entity);
                    sb.AppendLine($"    public INormQueryable<{safeEntity}> {safeEntity}s => this.Query<{safeEntity}>();");
                }
                sb.AppendLine("}");
                return sb.ToString();
            }
            finally
            {
                sb.Clear();
                _stringBuilderPool.Return(sb);
            }
        }

        /// <summary>
        /// Returns a C# type name with correct nullability for value or reference types.
        /// </summary>
        private static string GetTypeName(Type type, bool allowNull)
        {
            string name = type == typeof(byte[]) ? "byte[]" : type switch
            {
                var t when t == typeof(int) => "int",
                var t when t == typeof(long) => "long",
                var t when t == typeof(short) => "short",
                var t when t == typeof(byte) => "byte",
                var t when t == typeof(bool) => "bool",
                var t when t == typeof(string) => "string",
                var t when t == typeof(DateTime) => "DateTime",
                var t when t == typeof(decimal) => "decimal",
                var t when t == typeof(double) => "double",
                var t when t == typeof(float) => "float",
                var t when t == typeof(Guid) => "Guid",
                _ => type.FullName ?? type.Name
            };

            // Add '?' if the DB allows nulls (for both value types and reference types)
            if (allowNull)
            {
                if (name.EndsWith("[]", StringComparison.Ordinal))
                    name += "?";
                else if (type.IsValueType || type == typeof(string))
                    name += "?";
                else
                    name += "?";
            }

            return name;
        }

        private static string ToPascalCase(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) return name;

            var parts = name.Split(new[] { '_', ' ' }, StringSplitOptions.RemoveEmptyEntries);
            var sb = _stringBuilderPool.Get();
            try
            {
                foreach (var part in parts)
                {
                    sb.Append(char.ToUpperInvariant(part[0]));
                    if (part.Length > 1)
                        sb.Append(part[1..].ToLowerInvariant());
                }
                return sb.ToString();
            }
            finally
            {
                sb.Clear();
                _stringBuilderPool.Return(sb);
            }
        }

        private static string EscapeQualified(string schema, string table) => $"{schema}.{table}";

        private static string EscapeQualifiedIfNeeded(string? schema, string table) =>
            string.IsNullOrEmpty(schema) ? table : $"{schema}.{table}";

        private static string EscapeQualified(DatabaseProvider provider, string? schema, string table)
            => string.IsNullOrEmpty(schema) ? provider.Escape(table) : $"{provider.Escape(schema!)}.{provider.Escape(table)}";

        private static string EscapeIdentifier(DbConnection connection, string identifier)
        {
            // Support schema-qualified names by escaping each part separately.
            var parts = identifier.Split(new[] { '.' }, StringSplitOptions.RemoveEmptyEntries);
            var name = connection.GetType().Name.ToLowerInvariant();
            string Quote(string id) => name switch
            {
                var n when n.Contains("sqlconnection") => $"[{id}]",
                var n when n.Contains("sqlite") => $"\"{id}\"",
                var n when n.Contains("npgsql") => $"\"{id}\"",
                var n when n.Contains("mysql") => $"`{id}`",
                _ => id
            };
            return string.Join(".", parts.Select(Quote));
        }

        private static string EscapeCSharpIdentifier(string identifier)
        {
            if (string.IsNullOrEmpty(identifier)) return identifier;
            // Must start with a letter or underscore
            bool needsAt = _csharpKeywords.Contains(identifier)
                           || !(char.IsLetter(identifier[0]) || identifier[0] == '_')
                           || identifier.Any(ch => !(char.IsLetterOrDigit(ch) || ch == '_'));
            return needsAt ? "@" + identifier : identifier;
        }

        private static string GetUnqualifiedName(string identifier)
        {
            var idx = identifier.LastIndexOf('.');
            return idx >= 0 ? identifier[(idx + 1)..] : identifier;
        }

        private static string? GetSchemaNameOrNull(string identifier)
        {
            var idx = identifier.LastIndexOf('.');
            if (idx <= 0) return null;
            return identifier[..idx];
        }

        private static readonly HashSet<string> _csharpKeywords = new(StringComparer.Ordinal)
        {
            "abstract","as","base","bool","break","byte","case","catch","char","checked","class","const",
            "continue","decimal","default","delegate","do","double","else","enum","event","explicit","extern",
            "false","finally","fixed","float","for","foreach","goto","if","implicit","in","int","interface",
            "internal","is","lock","long","namespace","new","null","object","operator","out","override","params",
            "private","protected","public","readonly","ref","return","sbyte","sealed","short","sizeof","stackalloc",
            "static","string","struct","switch","this","throw","true","try","typeof","uint","ulong","unchecked",
            "unsafe","ushort","using","virtual","void","volatile","while","record","partial","var","dynamic"
        };
    }
}
